name: CD - Deploy to EKS

on:
    push:
        branches: [ main ]
    workflow_dispatch:

env:
    DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
    AWS_REGION: us-east-1
    EKS_CLUSTER_NAME: garage-cluster
    ECR_REPOSITORY: garage-app

jobs:
    # ========================================
    # JOB 1: TERRAFORM - Provisiona Infraestrutura AWS
    # ========================================
    terraform:
        name: Provision AWS Infrastructure
        runs-on: ubuntu-latest
        timeout-minutes: 30
        
        concurrency:
          group: terraform-production
          cancel-in-progress: false

        outputs:
          db_endpoint: ${{ steps.outputs.outputs.db_endpoint }}

        steps:
          - name: Checkout repository
            uses: actions/checkout@v4

          - name: Configure AWS credentials
            uses: aws-actions/configure-aws-credentials@v4
            with:
              aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
              aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
              aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
              aws-region: ${{ env.AWS_REGION }}

          - name: Verify AWS credentials
            run: |
              echo "âœ“ Verificando credenciais AWS..."
              aws sts get-caller-identity

          - name: Setup Terraform
            uses: hashicorp/setup-terraform@v3
            with:
              terraform_version: ${{ env.TF_VERSION }}
              terraform_wrapper: false

          - name: Terraform Init
            working-directory: ./infra
            run: |
              echo "Inicializando Terraform..."
              terraform init -input=false
              echo "Terraform inicializado"

          - name: Terraform Validate
            working-directory: ./infra
            run: |
              echo "Validando configuraÃ§Ã£o..."
              terraform validate
              echo "ConfiguraÃ§Ã£o vÃ¡lida"

          - name: Terraform Plan
            id: plan
            working-directory: ./infra
            run: |
              echo "Gerando plano de execuÃ§Ã£o..."
            
              set +e
              terraform plan -detailed-exitcode -out=tfplan
              PLAN_EXIT=$?
              set -e
            
              # Exit codes:
              # 0 = sem mudanÃ§as
              # 1 = erro
              # 2 = mudanÃ§as detectadas
            
              echo "plan_exit=$PLAN_EXIT" >> $GITHUB_OUTPUT
            
              if [ $PLAN_EXIT -eq 1 ]; then
                echo "Erro no Terraform Plan"
                exit 1
              elif [ $PLAN_EXIT -eq 2 ]; then
                echo "MudanÃ§as detectadas - serÃ¡ aplicado"
              else
                echo "Nenhuma mudanÃ§a necessÃ¡ria"
              fi

          - name: Terraform Apply
            if: steps.plan.outputs.plan_exit == '2'
            working-directory: ./infra
            run: |
              echo "Aplicando mudanÃ§as na infraestrutura..."
              terraform apply tfplan
              echo "Infraestrutura provisionada com sucesso!"

          - name: No changes needed
            if: steps.plan.outputs.plan_exit == '0'
            run: echo "Infraestrutura jÃ¡ estÃ¡ atualizada"
                  
          - name: Get Terraform Outputs
            id: outputs
            if: always()
            working-directory: ./infra
            run: |
              echo "Obtendo outputs do Terraform..."
                  
              # Verifica se o output existe antes de tentar obter
              if terraform output rds_endpoint >/dev/null 2>&1; then
                DB_ENDPOINT=$(terraform output -raw rds_endpoint)
                echo "db_endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
                echo "âœ“ DB Endpoint: $DB_ENDPOINT"
              else
                echo "db_endpoint=" >> $GITHUB_OUTPUT
                echo "Output rds_endpoint nÃ£o encontrado (pode ser primeira execuÃ§Ã£o)"
              fi
                  
    # ========================================
    # JOB 2: DEPLOY - Build e Deploy da AplicaÃ§Ã£o
    # ========================================
    deploy:
        name: Build and Deploy Application
        runs-on: ubuntu-latest
        needs: terraform

        steps:
            -   name: Checkout code
                uses: actions/checkout@v4

            -   name: Set up JDK 21
                uses: actions/setup-java@v4
                with:
                    java-version: '21'
                    distribution: 'temurin'
                    cache: maven

            -   name: Build application with Maven
                run: |
                    ./mvnw clean package -DskipTests
                    echo "Build da aplicaÃ§Ã£o concluÃ­do"
                    ls -lh target/*.jar

            -   name: Configure AWS credentials
                uses: aws-actions/configure-aws-credentials@v4
                with:
                    aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                    aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                    aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
                    aws-region: ${{ env.AWS_REGION }}

            -   name: Login to Amazon ECR
                id: login-ecr
                uses: aws-actions/amazon-ecr-login@v2

            -   name: Build and push Docker image
                env:
                    ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
                    IMAGE_TAG: ${{ github.sha }}
                run: |
                    IMAGE_TAG=${GITHUB_SHA}

                    docker build -t $ECR_REPOSITORY:$IMAGE_TAG .
                    docker tag $ECR_REPOSITORY:$IMAGE_TAG \
                        964022050595.dkr.ecr.us-east-1.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG

                    docker push \
                        964022050595.dkr.ecr.us-east-1.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG

                    echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

            -   name: Update kubeconfig
                run: |
                    aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

            # ğŸ” Buscar credenciais do banco no Secrets Manager
            -   name: Get DB secret from AWS
                id: db-secret
                run: |
                    SECRET=$(aws secretsmanager get-secret-value \
                      --secret-id $DB_SECRET_ARN \
                      --query SecretString \
                      --output text)

                    echo "DB_USER=$(echo $SECRET | jq -r .username)" >> $GITHUB_ENV
                    echo "DB_PASS=$(echo $SECRET | jq -r .password)" >> $GITHUB_ENV

            # ğŸ“ Aplicar ConfigMap
            -   name: Apply ConfigMap
                run: |
                    kubectl apply -f k8s/configmap.yaml

            # ğŸ” Aplicar Secret (usando YAML)
            -   name: Apply Secret
                run: |
                    # Codificar credenciais em base64
                    DB_USER_B64=$(echo -n "$DB_USER" | base64)
                    DB_PASS_B64=$(echo -n "$DB_PASS" | base64)
                    
                    # Substituir placeholders no YAML
                    sed -e "s|<BASE64_USERNAME>|$DB_USER_B64|g" \
                        -e "s|<BASE64_PASSWORD>|$DB_PASS_B64|g" \
                        k8s/db-secret.yaml | kubectl apply -f -

            # ğŸŒ Aplicar Service
            -   name: Apply Service
                run: |
                    kubectl apply -f k8s/service.yaml

            # ğŸ“¦ Aplicar Deployment
            -   name: Apply Deployment
                run: |
                    sed "s|\${IMAGE_TAG}|$IMAGE_TAG|g" k8s/deployment.yaml | kubectl apply -f -

            # ğŸ“Š Aplicar HPA
            -   name: Apply HPA
                run: |
                    kubectl apply -f k8s/hpa.yaml

            -   name: Wait rollout
                run: |
                    kubectl rollout status deployment/garage-app --timeout=5m
