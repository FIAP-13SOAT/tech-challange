name: CD - Deploy to EKS

on:
    push:
        branches: [ main ]
    workflow_dispatch:

env:
    DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
    AWS_REGION: us-east-1
    EKS_CLUSTER_NAME: garage-cluster
    ECR_REPOSITORY: garage-app

jobs:
    # ========================================
    # JOB 1: TERRAFORM - Provisiona Infraestrutura AWS
    # ========================================
    terraform:
      name: Provision Infrastructure with Terraform
      runs-on: ubuntu-latest

      concurrency:
        group: terraform-${{ github.ref }}
        cancel-in-progress: false

      outputs:
        db_endpoint: ${{ steps.tf-output.outputs.db_endpoint }}

      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
            aws-region: ${{ env.AWS_REGION }}

        - name: Setup Terraform
          uses: hashicorp/setup-terraform@v3
          with:
            terraform_version: 1.5.0

        - name: Terraform Init
          working-directory: ./infra
          run: |
            echo "ğŸ”§ Inicializando Terraform..."
            terraform init -input=false -upgrade

        - name: Terraform Plan
          id: plan
          working-directory: ./infra
          continue-on-error: true
          run: |
            echo "ğŸ“ Executando terraform plan..."
            terraform plan -detailed-exitcode
            echo "exitcode=$?" >> $GITHUB_OUTPUT

        - name: Fail if plan errored
          if: steps.plan.outputs.exitcode == '1'
          run: |
            echo "âŒ Terraform plan falhou. Abortando pipeline."
            exit 1

        - name: Terraform Apply - Deploy Infrastructure
          if: steps.plan.outputs.exitcode == '2'
          working-directory: ./infra
          run: |
            echo "ğŸš€ AlteraÃ§Ãµes detectadas. Aplicando infraestrutura..."
            terraform apply -auto-approve
            echo "âœ… Infraestrutura provisionada com sucesso!"

        - name: Skip Terraform Apply
          if: steps.plan.outputs.exitcode == '0'
          run: |
            echo "âœ… Infraestrutura jÃ¡ estÃ¡ atualizada. Pulando terraform apply."

        - name: Get Terraform Outputs
          id: tf-output
          working-directory: ./infra
          run: |
            echo "ğŸ“¤ Capturando outputs do Terraform..."
            DB_ENDPOINT=$(terraform output -raw rds_endpoint 2>/dev/null || true)
            echo "db_endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT


    # ========================================
    # JOB 2: DEPLOY - Build e Deploy da AplicaÃ§Ã£o
    # ========================================
    deploy:
        name: Build and Deploy Application
        runs-on: ubuntu-latest
        needs: terraform

        steps:
            -   name: Checkout code
                uses: actions/checkout@v4

            -   name: Set up JDK 21
                uses: actions/setup-java@v4
                with:
                    java-version: '21'
                    distribution: 'temurin'
                    cache: maven

            -   name: Build application with Maven
                run: |
                    ./mvnw clean package -DskipTests
                    echo "Build da aplicaÃ§Ã£o concluÃ­do"
                    ls -lh target/*.jar

            -   name: Configure AWS credentials
                uses: aws-actions/configure-aws-credentials@v4
                with:
                    aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                    aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                    aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
                    aws-region: ${{ env.AWS_REGION }}

            -   name: Login to Amazon ECR
                id: login-ecr
                uses: aws-actions/amazon-ecr-login@v2

            -   name: Build and push Docker image
                env:
                    ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
                    IMAGE_TAG: ${{ github.sha }}
                run: |
                    IMAGE_TAG=${GITHUB_SHA}

                    docker build -t $ECR_REPOSITORY:$IMAGE_TAG .
                    docker tag $ECR_REPOSITORY:$IMAGE_TAG \
                        964022050595.dkr.ecr.us-east-1.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG

                    docker push \
                        964022050595.dkr.ecr.us-east-1.amazonaws.com/$ECR_REPOSITORY:$IMAGE_TAG

                    echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

            -   name: Update kubeconfig
                run: |
                    aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

            # ğŸ” Buscar credenciais do banco no Secrets Manager
            -   name: Get DB secret from AWS
                id: db-secret
                run: |
                    SECRET=$(aws secretsmanager get-secret-value \
                      --secret-id $DB_SECRET_ARN \
                      --query SecretString \
                      --output text)

                    echo "DB_USER=$(echo $SECRET | jq -r .username)" >> $GITHUB_ENV
                    echo "DB_PASS=$(echo $SECRET | jq -r .password)" >> $GITHUB_ENV

            # ğŸ“ Aplicar ConfigMap
            -   name: Apply ConfigMap
                run: |
                    kubectl apply -f k8s/configmap.yaml

            # ğŸ” Aplicar Secret (usando YAML)
            -   name: Apply Secret
                run: |
                    # Codificar credenciais em base64
                    DB_USER_B64=$(echo -n "$DB_USER" | base64)
                    DB_PASS_B64=$(echo -n "$DB_PASS" | base64)
                    
                    # Substituir placeholders no YAML
                    sed -e "s|<BASE64_USERNAME>|$DB_USER_B64|g" \
                        -e "s|<BASE64_PASSWORD>|$DB_PASS_B64|g" \
                        k8s/db-secret.yaml | kubectl apply -f -

            # ğŸŒ Aplicar Service
            -   name: Apply Service
                run: |
                    kubectl apply -f k8s/service.yaml

            # ğŸ“¦ Aplicar Deployment
            -   name: Apply Deployment
                run: |
                    sed "s|\${IMAGE_TAG}|$IMAGE_TAG|g" k8s/deployment.yaml | kubectl apply -f -

            # ğŸ“Š Aplicar HPA
            -   name: Apply HPA
                run: |
                    kubectl apply -f k8s/hpa.yaml

            -   name: Wait rollout
                run: |
                    kubectl rollout status deployment/garage-app --timeout=5m
