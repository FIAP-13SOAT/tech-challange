name: CD - Deploy to EKS

on:
    push:
        branches: [ main ]
    workflow_dispatch:

env:
    AWS_REGION: us-east-1
    EKS_CLUSTER_NAME: garage-cluster
    ECR_REPOSITORY: garage-app

jobs:
    # ========================================
    # JOB 1: TERRAFORM - Provisiona Infraestrutura AWS
    # ========================================
    terraform:
      name: Provision Infrastructure with Terraform
      runs-on: ubuntu-latest

      concurrency:
        group: terraform-${{ github.ref }}
        cancel-in-progress: false

      outputs:
        db_endpoint: ${{ steps.tf-output.outputs.db_endpoint }}
        db_secret_arn: ${{ steps.tf-output.outputs.db_secret_arn }}

      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
            aws-region: ${{ env.AWS_REGION }}

        - name: Create S3 bucket for Terraform state if not exists
          run: |
            if ! aws s3 ls s3://garage-terraform-state-921831200874 2>/dev/null; then
              echo "Creating S3 bucket for Terraform state..."
              aws s3 mb s3://garage-terraform-state-921831200874 --region us-east-1
            else
              echo "S3 bucket already exists"
            fi

        - name: Setup Terraform
          uses: hashicorp/setup-terraform@v3
          with:
            terraform_version: 1.5.0
            terraform_wrapper: false

        - name: Terraform Init
          working-directory: ./infra
          run: terraform init -input=false

        - name: Terraform Plan
          id: plan
          working-directory: ./infra
          continue-on-error: true
          run: |
            set +e
            terraform plan -detailed-exitcode
            PLAN_EXIT_CODE=$?
            set -e
            echo "Plan exit code: $PLAN_EXIT_CODE"
            echo "exitcode=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
            

        - name: Terraform Apply
          if: steps.plan.outputs.exitcode == '2'
          working-directory: ./infra
          run: |
            echo "Applying infrastructure changes..."
            terraform apply -auto-approve

        - name: Get Terraform Outputs
          id: tf-output
          working-directory: ./infra
          if: always()
          run: |
            set +e
            DB_ENDPOINT=$(terraform output -raw rds_endpoint 2>/tmp/tf_err.log)
            DB_SECRET_ARN=$(terraform output -raw db_secret_arn 2>/tmp/tf_err.log)
            EXIT_CODE=$?
            set -e
            
            if [ $EXIT_CODE -eq 0 ]; then
              echo "db_endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
              echo "db_secret_arn=$DB_SECRET_ARN" >> $GITHUB_OUTPUT
            else
              echo "db_endpoint=" >> $GITHUB_OUTPUT
              echo "db_secret_arn=" >> $GITHUB_OUTPUT
            fi

    # ========================================
    # JOB 2: DEPLOY - Build e Deploy da Aplica√ß√£o
    # ========================================
    deploy:
        name: Build and Deploy Application
        runs-on: ubuntu-latest
        needs: terraform

        steps:
            -   name: Checkout code
                uses: actions/checkout@v4

            -   name: Set up JDK 21
                uses: actions/setup-java@v4
                with:
                    java-version: '21'
                    distribution: 'temurin'
                    cache: maven

            -   name: Build application with Maven
                run: |
                    ./mvnw clean package -DskipTests
                    echo "Build da aplica√ß√£o conclu√≠do"
                    ls -lh target/*.jar

            -   name: Configure AWS credentials
                uses: aws-actions/configure-aws-credentials@v4
                with:
                    aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                    aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                    aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
                    aws-region: ${{ env.AWS_REGION }}

            -   name: Verify AWS Account
                run: |
                    echo "Current AWS Account ID:"
                    aws sts get-caller-identity

            -   name: Login to Amazon ECR
                id: login-ecr
                uses: aws-actions/amazon-ecr-login@v2

            -   name: Build and push Docker image
                env:
                    ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
                    IMAGE_TAG: ${{ github.sha }}
                run: |
                    IMAGE_TAG=${GITHUB_SHA}

                    docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
                    docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

                    echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

            -   name: Update kubeconfig
                run: |
                    aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

            # üîê Criar secret para pull de imagens do ECR
            -   name: Create ECR pull secret
                env:
                    ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
                run: |
                    kubectl create secret docker-registry ecr-secret \
                      --namespace default \
                      --docker-server=$ECR_REGISTRY \
                      --docker-username=AWS \
                      --docker-password=$(aws ecr get-login-password --region ${{ env.AWS_REGION }}) \
                      --dry-run=client -o yaml | kubectl apply -f -

            # üîê Buscar credenciais do banco no Secrets Manager
            -   name: Get DB secret from AWS
                id: db-secret
                env:
                    DB_SECRET_ARN: ${{ needs.terraform.outputs.db_secret_arn }}
                run: |
                    SECRET=$(aws secretsmanager get-secret-value \
                      --secret-id $DB_SECRET_ARN \
                      --query SecretString \
                      --output text)

                    echo "DB_USER=$(echo $SECRET | jq -r .username)" >> $GITHUB_ENV
                    echo "DB_PASS=$(echo $SECRET | jq -r .password)" >> $GITHUB_ENV

            # üìù Aplicar ConfigMap
            -   name: Apply ConfigMap
                env:
                    DB_ENDPOINT: ${{ needs.terraform.outputs.db_endpoint }}
                run: |
                    sed -e "s|\${DB_ENDPOINT}|$DB_ENDPOINT|g" \
                        k8s/configmap.yaml | kubectl apply -f -

            # üîê Aplicar Secret (usando YAML)
            -   name: Apply Secret
                run: |
                    # Codificar credenciais em base64
                    DB_USER_B64=$(echo -n "$DB_USER" | base64)
                    DB_PASS_B64=$(echo -n "$DB_PASS" | base64)
                    
                    # Substituir placeholders no YAML
                    sed -e "s|<BASE64_USERNAME>|$DB_USER_B64|g" \
                        -e "s|<BASE64_PASSWORD>|$DB_PASS_B64|g" \
                        k8s/db-secret.yaml | kubectl apply -f -

            # üåê Aplicar Service
            -   name: Apply Service
                run: |
                    kubectl apply -f k8s/service.yaml

            # üì¶ Aplicar Deployment
            -   name: Apply Deployment
                env:
                    ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
                run: |
                    sed -e "s|\${IMAGE_TAG}|$IMAGE_TAG|g" \
                        -e "s|\${ECR_REGISTRY}|$ECR_REGISTRY|g" \
                        k8s/deployment.yaml | kubectl apply -f -

            # üìä Aplicar HPA
            -   name: Apply HPA
                run: |
                    kubectl apply -f k8s/hpa.yaml

            -   name: Wait rollout
                continue-on-error: true
                run: |
                    kubectl rollout status deployment/garage-app --timeout=5m